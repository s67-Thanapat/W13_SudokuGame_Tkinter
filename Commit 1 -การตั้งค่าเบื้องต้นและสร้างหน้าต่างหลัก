import tkinter as tk
from tkinter import filedialog, messagebox
import random
import copy

class SudokuGame:
    BOARD_SIZE = 9
    SUBGRID_SIZE = 3
    MAX_WRONG_ATTEMPTS = 3

    def __init__(self, master):
        self.master = master
        self.master.title("Sudoku")
        self.cell_size = 50
        self.solution = None
        self.wrong_attempts = 0
        self.game_over = False
        self.loaded_file_path = None

        self.game_frame = tk.Frame(master)
        self.create_game_interface()
        self.reset_board()

    def create_game_interface(self):
        self.canvas = tk.Canvas(self.game_frame, width=self.cell_size * self.BOARD_SIZE, height=self.cell_size * self.BOARD_SIZE)
        self.canvas.grid(row=0, column=0, columnspan=self.BOARD_SIZE)

        self.create_grid()
        self.cells = self.create_input_fields()
        self.create_game_buttons()
        self.game_frame.pack()

    def create_input_fields(self):
        cells = []
        for i in range(self.BOARD_SIZE):
            row = []
            for j in range(self.BOARD_SIZE):
                var = tk.StringVar()
                vcmd = (self.master.register(self.validate_input), '%P')
                entry = tk.Entry(self.game_frame, width=2, justify='center', font=('Arial', 18),
                                 textvariable=var, validate='key', validatecommand=vcmd)
                entry.place(x=j * self.cell_size + 5, y=i * self.cell_size + 5,
                           width=self.cell_size - 10, height=self.cell_size - 10)
                var.trace_add('write', lambda name, index, mode, var=var, i=i, j=j: self.validate_cell(var, i, j))
                row.append(entry)
            cells.append(row)
        return cells

    def create_game_buttons(self):
        self.reset_button = tk.Button(self.game_frame, text="Reset Game", command=self.reset_board, state=tk.NORMAL)
        self.reset_button.grid(row=10, column=4, columnspan=2, pady=10)

        self.save_button = tk.Button(self.game_frame, text="Save Game", command=self.save_game, state=tk.NORMAL)
        self.save_button.grid(row=10, column=6, columnspan=2, pady=10)

        self.load_button = tk.Button(self.game_frame, text="Load Game", command=self.load_game, state=tk.NORMAL)
        self.load_button.grid(row=10, column=1, columnspan=2, pady=10)

        # เพิ่ม Label สำหรับแสดงจำนวนความผิดพลาด
        self.wrong_attempts_label = tk.Label(self.game_frame, text=f"ผิดพลาด: {self.wrong_attempts}/{self.MAX_WRONG_ATTEMPTS}", font=('Arial', 12))
        self.wrong_attempts_label.grid(row=10, column=0, padx=10, pady=10, sticky='w')  # วางไว้ที่แถว 10 คอลัมน์ 0

    def create_grid(self):
        for i in range(self.BOARD_SIZE + 1):
            line_width = 3 if i % self.SUBGRID_SIZE == 0 else 1
            self.canvas.create_line(0, i * self.cell_size, self.cell_size * self.BOARD_SIZE, i * self.cell_size, width=line_width)
            self.canvas.create_line(i * self.cell_size, 0, i * self.cell_size, self.cell_size * self.BOARD_SIZE, width=line_width)

    def reset_board(self):
        self.game_over = False
        self.wrong_attempts = 0
        self.update_wrong_attempts_label()  # รีเซ็ตและอัปเดต Label
        board = [[0 for _ in range(self.BOARD_SIZE)] for _ in range(self.BOARD_SIZE)]
        self.fill_board(board)
        self.solution = copy.deepcopy(board)
        self.remove_numbers_from_board(board)
        self.starting_puzzle = copy.deepcopy(board)
        self.update_cells(board)

        for row in self.cells:
            for cell in row:
                cell.config(bg='white')

        self.save_button.config(state=tk.NORMAL)

    def fill_board(self, board):
        def is_valid(board, row, col, num):
            for i in range(self.BOARD_SIZE):
                if board[row][i] == num or board[i][col] == num:
                    return False
            start_row, start_col = self.SUBGRID_SIZE * (row // self.SUBGRID_SIZE), self.SUBGRID_SIZE * (col // self.SUBGRID_SIZE)
            for i in range(self.SUBGRID_SIZE):
                for j in range(self.SUBGRID_SIZE):
                    if board[start_row + i][start_col + j] == num:
                        return False
            return True

        def solve(board):
            for row in range(self.BOARD_SIZE):
                for col in range(self.BOARD_SIZE):
                    if board[row][col] == 0:
                        nums = list(range(1, self.BOARD_SIZE + 1))
                        random.shuffle(nums)
                        for num in nums:
                            if is_valid(board, row, col, num):
                                board[row][col] = num
                                if solve(board):
                                    return True
                                board[row][col] = 0
                        return False
            return True

        solve(board)

    def remove_numbers_from_board(self, board):
        num_to_remove = 30  # คงเหลือ 30 เซลล์ที่กรอก
        removed = 0
        while removed < num_to_remove:
            row = random.randint(0, self.BOARD_SIZE - 1)
            col = random.randint(0, self.BOARD_SIZE - 1)
            if board[row][col] != 0:
                board[row][col] = 0
                removed += 1

    def validate_input(self, P):
        return P == "" or (P.isdigit() and len(P) == 1 and 1 <= int(P) <= 9)

    def validate_cell(self, var, row, col):
        if self.game_over or self.solution is None:
            return

        value = var.get()
        entry = self.cells[row][col]
        if value == "":
            entry.config(bg='white')
            return

        try:
            user_num = int(value)
        except ValueError:
            entry.config(bg='red')
            return

        correct_num = self.solution[row][col]
        if user_num == correct_num:
            entry.config(bg='green')  # เปลี่ยนสีเซลล์ที่ถูกต้องเป็นสีเขียว
            if self.check_victory():
                self.end_game_with_victory()
        else:
            if entry.cget('bg') != 'red':
                self.wrong_attempts += 1
                self.update_wrong_attempts_label()  # อัปเดต Label เมื่อมีความผิดพลาด
                if self.wrong_attempts >= self.MAX_WRONG_ATTEMPTS:
                    self.end_game()
                else:
                    remaining_attempts = self.MAX_WRONG_ATTEMPTS - self.wrong_attempts
                    messagebox.showinfo("Incorrect", f"คุณกรอกเลขผิด! คุณเหลือโอกาสอีก: {remaining_attempts}")
            entry.config(bg='red')

    def update_cells(self, board):
        for i in range(self.BOARD_SIZE):
            for j in range(self.BOARD_SIZE):
                self.cells[i][j].config(state='normal', bg='white')
                self.cells[i][j].delete(0, tk.END)
                if board[i][j] != 0:
                    self.cells[i][j].insert(0, str(board[i][j]))
                    self.cells[i][j].config(state='disabled', disabledforeground='black')

    def load_game(self):
        file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")])
        if file_path:
            self.loaded_file_path = file_path
            with open(file_path, 'r') as file:
                lines = file.readlines()
                if len(lines) < self.BOARD_SIZE + 1:
                    messagebox.showerror("Error", "ไฟล์เกมไม่สมบูรณ์หรือผิดรูปแบบ")
                    return

                try:
                    # อ่านจำนวนความผิดพลาดจากบรรทัดแรก
                    self.wrong_attempts = int(lines[0].strip())
                    board = []
                    for line in lines[1:self.BOARD_SIZE + 1]:
                        board.append(list(map(int, line.strip().split())))
                except ValueError:
                    messagebox.showerror("Error", "ไฟล์เกมมีข้อมูลที่ไม่ถูกต้อง")
                    return

            self.starting_puzzle = copy.deepcopy(board)
            self.solution = self.generate_solution(board)

            self.update_cells(self.starting_puzzle)

            # อัปเดตสีของเซลล์ที่ถูกกรอก
            for i in range(self.BOARD_SIZE):
                for j in range(self.BOARD_SIZE):
                    user_input = self.cells[i][j].get()
                    if user_input != "" and user_input == str(self.solution[i][j]):
                        self.cells[i][j].config(bg='green')  # เปลี่ยนสีเป็นเขียวถ้าถูกต้อง
                    elif board[i][j] != 0:
                        self.cells[i][j].config(bg='white')  # ถ้าเซลล์มีตัวเลขในปริศนาให้เปลี่ยนเป็นสีขาว

            self.update_wrong_attempts_label()  # อัปเดต Label เมื่อโหลดเกม
            self.game_over = False
            self.save_button.config(state=tk.NORMAL)

            # ตรวจสอบว่าเกมจบหรือไม่หลังจากโหลด
            if self.wrong_attempts >= self.MAX_WRONG_ATTEMPTS:
                self.end_game()

    def save_game(self):
        if self.loaded_file_path:
            file_path = self.loaded_file_path
        else:
            file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")])
            if not file_path:
                return
            self.loaded_file_path = file_path  # บันทึกชื่อไฟล์ที่ผู้ใช้เลือกไว้

        with open(file_path, 'w') as file:
            # บันทึกจำนวนความผิดพลาดเป็นบรรทัดแรก
            file.write(f"{self.wrong_attempts}\n")
            for i in range(self.BOARD_SIZE):
                row_data = []
                for j in range(self.BOARD_SIZE):
                    user_input = self.cells[i][j].get()
                    # เซฟเฉพาะตัวเลขที่ผู้เล่นกรอกและถูกต้อง
                    if user_input and user_input == str(self.solution[i][j]):
                        row_data.append(user_input)
                    else:
                        row_data.append('0')  # หรือใช้ '0' เพื่อแสดงว่าตัวเลขไม่ได้ถูกกรอกหรือไม่ถูกต้อง
                file.write(' '.join(row_data) + '\n')
        messagebox.showinfo("Save Game", "เกมถูกบันทึกเรียบร้อยแล้ว!")


    def generate_solution(self, board):
        board_copy = copy.deepcopy(board)
        
        def is_valid(board, row, col, num):
            for i in range(self.BOARD_SIZE):
                if board[row][i] == num or board[i][col] == num:
                    return False
            start_row, start_col = self.SUBGRID_SIZE * (row // self.SUBGRID_SIZE), self.SUBGRID_SIZE * (col // self.SUBGRID_SIZE)
            for i in range(self.SUBGRID_SIZE):
                for j in range(self.SUBGRID_SIZE):
                    if board[start_row + i][start_col + j] == num:
                        return False
            return True

        def solve(board):
            for row in range(self.BOARD_SIZE):
                for col in range(self.BOARD_SIZE):
                    if board[row][col] == 0:
                        nums = list(range(1, self.BOARD_SIZE + 1))
                        random.shuffle(nums)
                        for num in nums:
                            if is_valid(board, row, col, num):
                                board[row][col] = num
                                if solve(board):
                                    return True
                                board[row][col] = 0
                        return False
            return True

        solve(board_copy)
        return board_copy

    def check_victory(self):
        for row in range(self.BOARD_SIZE):
            for col in range(self.BOARD_SIZE):
                if self.cells[row][col].get() != str(self.solution[row][col]):
                    return False
        return True

    def end_game_with_victory(self):
        messagebox.showinfo("Congratulations!", "ยินดีด้วยคุณ ชนะเเล้ว!")
        self.game_over = True

    def end_game(self):
        messagebox.showinfo("Game Over", "เกมจบแล้ว! คุณแพ้!\nเมื่อคุณกดปุ่ม OK เกมจะเริ่มใหม่")
        self.reset_board()

    def update_wrong_attempts_label(self):
        """อัปเดตข้อความใน Label แสดงจำนวนความผิดพลาด"""
        self.wrong_attempts_label.config(text=f"ผิดพลาดไป: {self.wrong_attempts}/{self.MAX_WRONG_ATTEMPTS}")

if __name__ == "__main__":
    root = tk.Tk()
    game = SudokuGame(root)
    root.mainloop()
